AWSTemplateFormatVersion: '2010-09-09'
Description: 'Tenant Creator Lambda for Stellar Disbursement Platform'

Parameters:
  NetworkStackName:
    Type: String
    Default: "sdp-network-ecs"
    Description: Name of the network stack to import values from

  DomainName:
    Type: String
    Description: Domain name for the SDP deployment

  AdminApiKey:
    Type: String
    Description: Admin API key for tenant creation
    NoEcho: true

  TenantName:
    Type: String
    Default: "default"
    Description: Name of the tenant to create
    AllowedPattern: "^[a-z-]+$"
    ConstraintDescription: "Tenant name should match the pattern ^[a-z-]+$"

  DistributionAccountType:
    Type: String
    Default: "DISTRIBUTION_ACCOUNT.STELLAR.DB_VAULT"
    Description: The distribution account type of the tenant
    AllowedValues:
      - "DISTRIBUTION_ACCOUNT.STELLAR.ENV"
      - "DISTRIBUTION_ACCOUNT.STELLAR.DB_VAULT"
      - "DISTRIBUTION_ACCOUNT.CIRCLE.DB_VAULT"

  OwnerEmail:
    Type: String
    Description: The owner user e-mail address

  OwnerFirstName:
    Type: String
    Description: The owner user first name

  OwnerLastName:
    Type: String
    Description: The owner user last name

  OrganizationName:
    Type: String
    Description: The organization name

  BaseUrl:
    Type: String
    Default: ""
    Description: The SDP backend server's base URL (optional)

  SdpUiBaseUrl:
    Type: String
    Default: ""
    Description: The SDP UI/dashboard Base URL (optional)

Resources:
  # Lambda execution role
  TenantCreatorLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: VPCAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:CreateNetworkInterface
                  - ec2:DescribeNetworkInterfaces
                  - ec2:DeleteNetworkInterface
                Resource: '*'

  # Lambda function to create a tenant
  TenantCreatorLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: nodejs18.x
      Role: !GetAtt TenantCreatorLambdaRole.Arn
      Handler: index.handler
      Timeout: 60
      VpcConfig:
        SecurityGroupIds: 
          - Fn::ImportValue: !Sub "${NetworkStackName}-ecs-services-sg"
        SubnetIds: 
          - Fn::ImportValue: !Sub "${NetworkStackName}-private-subnet-1"
          - Fn::ImportValue: !Sub "${NetworkStackName}-private-subnet-2"
      Environment:
        Variables:
          DOMAIN_NAME: !Ref DomainName
          ADMIN_API_KEY: !Ref AdminApiKey
      Code:
        ZipFile: |
          const https = require('https');

          exports.handler = async (event) => {
            console.log('Event:', JSON.stringify(event));
            
            // Handle CloudFormation custom resource events
            if (event.RequestType) {
              const responseData = {};
              // Always send success response to prevent stack from failing
              let responseStatus = 'SUCCESS';
              
              try {
                // Extract the CloudFormation request details
                const { RequestType, ResourceProperties } = event;
                
                switch (RequestType) {
                  case 'Create':
                  case 'Update':
                    try {
                      // Process the tenant creation or update
                      const tenantResult = await createTenant(ResourceProperties);
                      responseData.TenantId = tenantResult.createTenantResult?.id || 'unknown';
                      responseData.Message = 'Tenant creation successful';
                    } catch (error) {
                      // Log error but don't fail the stack
                      console.error('Error creating tenant, but continuing:', error);
                      responseData.Error = error.message;
                      responseData.Message = 'Tenant creation failed but stack will continue';
                      // Still return SUCCESS to CloudFormation
                    }
                    break;
                    
                  case 'Delete':
                    // For Delete events, just log and continue to response
                    console.log('Delete request received. No-op success response.');
                    responseData.Message = 'Delete operation is a no-op';
                    break;
                    
                  default:
                    console.log(`Unsupported request type: ${RequestType}, but continuing`);
                    responseData.Message = `Unsupported request type: ${RequestType}`;
                }
              } catch (error) {
                console.error('Error processing CloudFormation request:', error);
                responseData.Error = error.message;
                responseData.Message = 'Error occurred but stack will continue';
                // Still return SUCCESS to CloudFormation
              }
              
              // Send response back to CloudFormation - this happens for ALL RequestType values
              await sendCloudFormationResponse(event, responseStatus, responseData);
              return { responseStatus, responseData }; // Return something meaningful
            }
              
            // Direct Lambda invocation (not from CloudFormation)
            try {
              return await createTenant(event);
            } catch (error) {
              console.error('Error:', error);
              return {
                statusCode: 500,
                body: {
                  error: error.message
                }
              };
            }
          };
          
          async function createTenant(params) {
            const domain = process.env.DOMAIN_NAME;
            const apiKey = process.env.ADMIN_API_KEY;
            
            // Create authorization
            const authorization = Buffer.from(`admin:${apiKey}`).toString('base64');
            
            // Check API health
            await checkApiHealth(domain, authorization);
            
            // Create tenant payload using provided parameters
            const createPayload = {
              name: params.name,
              owner_email: params.owner_email,
              owner_first_name: params.owner_first_name,
              owner_last_name: params.owner_last_name,
              organization_name: params.organization_name,
              distribution_account_type: params.distribution_account_type
            };
            
            // Add optional parameters if provided
            if (params.base_url) {
              createPayload.base_url = params.base_url;
            } else {
              createPayload.base_url = `https://${params.name}.${domain}`;
            }
            
            if (params.sdp_ui_base_url) {
              createPayload.sdp_ui_base_url = params.sdp_ui_base_url;
            } else {
              createPayload.sdp_ui_base_url = `https://${params.name}.${domain}`;
            }

            // Log the payload for debugging
            console.log('Creating tenant with payload:', JSON.stringify(createPayload));

            try {
              // Create tenant
              const createTenantResult = await sendRequest(domain, authorization, '/tenants/', 'POST', createPayload);
              console.log('Tenant Creation Result:', createTenantResult);

              // List tenants
              const listTenantsResult = await sendRequest(domain, authorization, '/tenants', 'GET');
              console.log('Tenant List:', JSON.stringify(listTenantsResult, null, 2));

              return {
                statusCode: 200,
                body: {
                  createTenantResult,
                  tenantsList: listTenantsResult
                }
              };
            } catch (error) {
              console.error('Failed to create tenant:', error);
              throw error; // Propagate error to caller, but this won't fail the stack
            }
          }
          
          async function checkApiHealth(domain, authorization) {
            try {
              // Try simple endpoints that should be available
              const endpoints = ['/health', '/', '/tenants'];
              
              for (const endpoint of endpoints) {
                try {
                  console.log(`Checking API health with endpoint: ${endpoint}`);
                  const result = await sendRequest(domain, authorization, endpoint, 'GET');
                  console.log(`API health check succeeded with endpoint: ${endpoint}`);
                  return true;
                } catch (error) {
                  console.log(`Health check failed for endpoint ${endpoint}: ${error.message}`);
                  // Continue to next endpoint
                }
              }
              
              // All health checks failed, but we'll continue anyway
              console.log('All health checks failed, but continuing anyway');
              return false;
            } catch (error) {
              console.error('API health check completely failed:', error);
              // Continue anyway
              return false;
            }
          }
          
          // Function to send response back to CloudFormation
          async function sendCloudFormationResponse(event, responseStatus, responseData) {
            const responseBody = JSON.stringify({
              Status: responseStatus,
              Reason: `See the details in CloudWatch Log Stream: ${process.env.AWS_LAMBDA_LOG_STREAM_NAME}`,
              PhysicalResourceId: event.PhysicalResourceId || event.LogicalResourceId,
              StackId: event.StackId,
              RequestId: event.RequestId,
              LogicalResourceId: event.LogicalResourceId,
              Data: responseData
            });

            console.log('Sending response to CloudFormation:', responseBody);

            const parsedUrl = new URL(event.ResponseURL);
            const options = {
              hostname: parsedUrl.hostname,
              port: 443,
              path: parsedUrl.pathname + parsedUrl.search,
              method: 'PUT',
              headers: {
                'Content-Type': '',
                'Content-Length': responseBody.length
              }
            };

            return new Promise((resolve, reject) => {
              const req = https.request(options, (res) => {
                console.log(`CloudFormation response status: ${res.statusCode}`);
                resolve();
              });

              req.on('error', (error) => {
                console.error('Error sending response to CloudFormation:', error);
                // Don't reject, just log the error and resolve anyway
                // This ensures CloudFormation gets a response even if there's an error
                resolve();
              });

              req.write(responseBody);
              req.end();
            });
          }

          function sendRequest(domain, authorization, path, method, payload = null) {
            return new Promise((resolve, reject) => {
              const fullUrl = `https://admin.${domain}${path}`;
              console.log(`Making request to: ${fullUrl}`);
              
              const options = {
                hostname: `admin.${domain}`,
                port: 443,
                path: path,
                method: method,
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Basic ${authorization}`,
                  'Host': `admin.${domain}`
                },
                timeout: 10000
              };

              const req = https.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => {
                  data += chunk;
                });
                res.on('end', () => {
                  if (res.statusCode >= 200 && res.statusCode < 300) {
                    try {
                      const parsedData = data ? JSON.parse(data) : {};
                      resolve(parsedData);
                    } catch (error) {
                      console.error('Error parsing response data:', error);
                      reject(new Error(`Failed to parse API response: ${error.message}`));
                    }
                  } else {
                    reject(new Error(`API error: ${res.statusCode} ${data}`));
                  }
                });
              });

              req.on('timeout', () => {
                req.destroy();
                reject(new Error('Request timed out'));
              });

              req.on('error', (error) => {
                reject(error);
              });

              if (payload) {
                const payloadString = JSON.stringify(payload);
                console.log(`Sending payload: ${payloadString}`);
                req.write(payloadString);
              }
              req.end();
            });
          }

  # Custom resource to invoke the Lambda with parameters
  DefaultTenantResource:
    Type: Custom::DefaultTenant
    Properties:
      ServiceToken: !GetAtt TenantCreatorLambda.Arn
      name: !Ref TenantName
      distribution_account_type: !Ref DistributionAccountType
      owner_email: !Ref OwnerEmail
      owner_first_name: !Ref OwnerFirstName
      owner_last_name: !Ref OwnerLastName
      organization_name: !Ref OrganizationName
      base_url: !Ref BaseUrl
      sdp_ui_base_url: !Ref SdpUiBaseUrl

Outputs:
  StackName:
    Description: "The name of this stack"
    Value: !Ref AWS::StackName
    
  TenantCreatorLambdaArn:
    Description: ARN of the Tenant Creator Lambda
    Value: !GetAtt TenantCreatorLambda.Arn
    Export:
      Name: !Sub ${AWS::StackName}-lambda-arn

  InvokeLambdaCommand:
    Description: Sample AWS CLI command to invoke the Lambda
    Value: !Sub |
      aws lambda invoke --function-name ${TenantCreatorLambda} --payload '{"name":"${TenantName}","distribution_account_type":"${DistributionAccountType}","owner_email":"${OwnerEmail}","owner_first_name":"${OwnerFirstName}","owner_last_name":"${OwnerLastName}","organization_name":"${OrganizationName}"}' --region ${AWS::Region} response.json && cat response.json
