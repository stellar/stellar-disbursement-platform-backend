package utils

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
)

const keyBytes = 16

// Encrypt secures a message using the AES GCM cipher mode which requires the use of
// a passphrase for authentication.
func Encrypt(message string, passphrase string) (string, error) {
	passHash := sha256.New()
	passHash.Write([]byte(passphrase))

	key := make([]byte, keyBytes)
	copy(key, passHash.Sum(nil))

	block, err := aes.NewCipher(key)
	if err != nil {
		return "", fmt.Errorf("creating new cipher: %w", err)
	}

	gcmCipher, err := cipher.NewGCM(block)
	if err != nil {
		return "", fmt.Errorf("creating new gcm cipher: %w", err)
	}

	nonce := make([]byte, gcmCipher.NonceSize())
	lenRead, err := rand.Read(nonce)
	if err != nil {
		return "", fmt.Errorf("error while generating random nonce: %w", err)
	}
	if lenRead != gcmCipher.NonceSize() {
		return "", fmt.Errorf("length of generated nonce %d different from expected length %d", lenRead, gcmCipher.NonceSize())
	}

	cipheredText := gcmCipher.Seal(nonce, nonce, []byte(message), nil)
	return base64.StdEncoding.EncodeToString(cipheredText), nil
}

// Decrypt recovers the original message from a secured one generated by Encrypt.
func Decrypt(message string, passphrase string) (string, error) {
	passHash := sha256.New()
	passHash.Write([]byte(passphrase))

	key := make([]byte, keyBytes)
	copy(key, passHash.Sum(nil))

	block, err := aes.NewCipher(key)
	if err != nil {
		return "", fmt.Errorf("creating new cipher: %w", err)
	}

	gcmCipher, err := cipher.NewGCM(block)
	if err != nil {
		return "", fmt.Errorf("creating new gcm cipher: %w", err)
	}

	decodedMsg, err := base64.StdEncoding.DecodeString(message)
	if err != nil {
		return "", fmt.Errorf("decoding message: %w", err)
	}

	nonceSize := gcmCipher.NonceSize()
	nonce, cipheredText := decodedMsg[:nonceSize], decodedMsg[nonceSize:]

	plainText, err := gcmCipher.Open(nil, nonce, cipheredText, nil)
	if err != nil {
		return "", fmt.Errorf("decrypting and authenticating message: %w", err)
	}

	return string(plainText), nil
}
