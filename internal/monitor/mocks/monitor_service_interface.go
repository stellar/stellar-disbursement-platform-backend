// Code generated by mockery v2.40.1. DO NOT EDIT.

package mocks

import (
	http "net/http"
	time "time"

	monitor "github.com/stellar/stellar-disbursement-platform-backend/internal/monitor"
	mock "github.com/stretchr/testify/mock"
)

// MockMonitorService is an autogenerated mock type for the MonitorServiceInterface type
type MockMonitorService struct {
	mock.Mock
}

// GetMetricHttpHandler provides a mock function with given fields:
func (_m *MockMonitorService) GetMetricHttpHandler() (http.Handler, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetMetricHttpHandler")
	}

	var r0 http.Handler
	var r1 error
	if rf, ok := ret.Get(0).(func() (http.Handler, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() http.Handler); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(http.Handler)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMetricType provides a mock function with given fields:
func (_m *MockMonitorService) GetMetricType() (monitor.MetricType, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetMetricType")
	}

	var r0 monitor.MetricType
	var r1 error
	if rf, ok := ret.Get(0).(func() (monitor.MetricType, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() monitor.MetricType); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(monitor.MetricType)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MonitorCounters provides a mock function with given fields: tag, labels
func (_m *MockMonitorService) MonitorCounters(tag monitor.MetricTag, labels map[string]string) error {
	ret := _m.Called(tag, labels)

	if len(ret) == 0 {
		panic("no return value specified for MonitorCounters")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(monitor.MetricTag, map[string]string) error); ok {
		r0 = rf(tag, labels)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MonitorDBQueryDuration provides a mock function with given fields: duration, tag, labels
func (_m *MockMonitorService) MonitorDBQueryDuration(duration time.Duration, tag monitor.MetricTag, labels monitor.DBQueryLabels) error {
	ret := _m.Called(duration, tag, labels)

	if len(ret) == 0 {
		panic("no return value specified for MonitorDBQueryDuration")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(time.Duration, monitor.MetricTag, monitor.DBQueryLabels) error); ok {
		r0 = rf(duration, tag, labels)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MonitorDuration provides a mock function with given fields: duration, tag, labels
func (_m *MockMonitorService) MonitorDuration(duration time.Duration, tag monitor.MetricTag, labels map[string]string) error {
	ret := _m.Called(duration, tag, labels)

	if len(ret) == 0 {
		panic("no return value specified for MonitorDuration")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(time.Duration, monitor.MetricTag, map[string]string) error); ok {
		r0 = rf(duration, tag, labels)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MonitorHistogram provides a mock function with given fields: value, tag, labels
func (_m *MockMonitorService) MonitorHistogram(value float64, tag monitor.MetricTag, labels map[string]string) error {
	ret := _m.Called(value, tag, labels)

	if len(ret) == 0 {
		panic("no return value specified for MonitorHistogram")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(float64, monitor.MetricTag, map[string]string) error); ok {
		r0 = rf(value, tag, labels)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MonitorHttpRequestDuration provides a mock function with given fields: duration, labels
func (_m *MockMonitorService) MonitorHttpRequestDuration(duration time.Duration, labels monitor.HttpRequestLabels) error {
	ret := _m.Called(duration, labels)

	if len(ret) == 0 {
		panic("no return value specified for MonitorHttpRequestDuration")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(time.Duration, monitor.HttpRequestLabels) error); ok {
		r0 = rf(duration, labels)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Start provides a mock function with given fields: opts
func (_m *MockMonitorService) Start(opts monitor.MetricOptions) error {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(monitor.MetricOptions) error); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewMockMonitorService creates a new instance of MockMonitorService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMonitorService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMonitorService {
	mock := &MockMonitorService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
